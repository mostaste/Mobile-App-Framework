package Jomo;import java.util.ArrayList;import java.util.List;import java.util.Random;import android.graphics.Color;import android.graphics.Paint;import com.JomoFramework.Game;import com.JomoFramework.Graphics;import com.JomoFramework.Screen;import com.JomoFramework.Input.TouchEvent;public class GameScreen extends Screen{    /*********************  Game Declaration *********************/    //  Game States (0 - Menu, 1 - Running, 2 - Paused, 3 - GameOver)    private int gamestate;    private int gamestateTemp;    // Player Sprites    private Player player;    private Animation animPlayer;    private boolean touchFlag;    private boolean gameoverFlag;    // Background    private boolean bgSpawn;    private Random bgRand;    private ArrayList<Background> bglist;    // Options    private boolean optionFlag;    private boolean soundFlag;    private boolean musicFlag;    private int xButtons;    private int ySettings, ySound, yMusic;    private int buttonRadius;    // Enemy Sprite    private Random enemyRand;    private Animation animEnemy;    private ArrayList<Enemy> activeEnemylist;    private int activeEnemySpawn[];    private int activeEnemySize;    private int activeEnemySpeed;    private boolean bActiveEnemySpawn;    private boolean bIncreaseActiveEnemySpawn;    private boolean bActiveEnemySpawnFlag;    private ArrayList<Enemy> staticEnemylist;    private int staticEnemySpawn[];    private int staticEnemySize;    private int staticEnemySpeed;    private boolean bStaticEnemySpawn;    private boolean bExplosionTouchFlag;    private int explosiontimer;    private int activeEnemyXRadius;    private int activeEnemyYRadius;    // Score    private int score;    private int scoretimer;    private Paint paint, paint2, paintBig;    Graphics g = game.getGraphics();    /*********************  Game Creator *********************/    public GameScreen(Game game)    {        super(game);        gamestate = 0;        gamestateTemp = gamestate;        ConstructPlayer();        ConstructBackground();        ConstructEnemy();        ConstructOptions();        ConstructScore();    }    /*********************  Game Screen Interface *********************/    @Override    public void update(float deltaTime)    {        // Depending on the state of the game, we call different update methods        List<TouchEvent> touchEvents = game.getInput().getTouchEvents();        if (gamestate == 0)      {  updateMenu(touchEvents, deltaTime);     }        else if (gamestate == 1) {  updateRunning(touchEvents, deltaTime);  }        else if (gamestate == 2) {  updatePaused(touchEvents);              }        else if (gamestate == 3) {  updateGameOver(touchEvents);            }    }    @Override    public void paint(float deltaTime)    {        // Draw the game elements [ Image drawn from top right hand corner ]        if (gamestate == 0)      {  drawMenuUI();       }        else if (gamestate == 1) {  drawRunningUI();    }        else if (gamestate == 2) {  drawPausedUI();     }        else if (gamestate == 3) {  drawGameOverUI();   }    }    @Override    public void pause()    {        gamestateTemp = gamestate;        gamestate = 2;        MusicController(true);    }    @Override    public void resume()    {        gamestate = gamestateTemp;        MusicController(false);    }    @Override    public void dispose(){}    @Override    public void backButton()    {        if(gamestate != 2)            pause();        else            resume();    }    /*********************  Box and Buttons *********************/    private boolean inBounds(TouchEvent event, int x, int y, int width, int height)    {        if ((event.x > x && event.x < x + width) && (event.y > y && event.y < y + height))            return true;        else            return false;    }    //TODO Exit Box?/**********************************************************************************************/    /*********************  Game Drawing *********************/    // Sprites are Drawn from the Top Left Hand Corner    private void drawMenuUI()    {        g.drawImage(Assets.skybackground, 0, 0);        g.drawImage(Assets.sunbackground, -120, -500);        for (int i = 0; i < bglist.size(); i++)            g.drawImage(bglist.get(i).getBgImage(), bglist.get(i).getX(), bglist.get(i).getY());        g.drawImage(animPlayer.getImage(), player.getX(), player.getY());        if(optionFlag)        {            g.drawImage(Assets.exitButton, xButtons, ySettings);            if(!soundFlag)                g.drawImage(Assets.soundButton, xButtons, ySound);            else                g.drawImage(Assets.noSoundButton, xButtons, ySound);            if(!musicFlag)                g.drawImage(Assets.musicButton, xButtons, yMusic);            else                g.drawImage(Assets.noMusicButton, xButtons, yMusic);        }        else            g.drawImage(Assets.settingsButton, xButtons, ySettings);        g.drawString(Integer.toString(game.getHighScore()), Assets.xScore, Assets.yScore, paint);    }    private void drawRunningUI()    {        g.drawImage(Assets.skybackground, 0, 0);        g.drawImage(Assets.sunbackground, -120, -500);        g.drawString(Integer.toString(score), Assets.xScore, Assets.yScore, paint);        for (int i = 0; i < bglist.size(); i++)            g.drawImage(bglist.get(i).getBgImage(), bglist.get(i).getX(), bglist.get(i).getY());        g.drawImage(animPlayer.getImage(), player.getX(), player.getY());        for (int i = 0; i < activeEnemylist.size(); i++)        {            if(activeEnemylist.get(i).getX() < 900)                g.drawImage(animEnemy.getImage(), activeEnemylist.get(i).getX(), activeEnemylist.get(i).getY());        }        for (int i = 0; i < staticEnemylist.size(); i++)        {            if(staticEnemylist.get(i).getX() < 900)                g.drawImage(staticEnemylist.get(i).getEnemyImage(), staticEnemylist.get(i).getX(), staticEnemylist.get(i).getY());        }        if(bExplosionTouchFlag)        {            g.drawImage(Assets.explosion0, player.getX(), player.getY());            if(!soundFlag)                Assets.explosionSound.play(0.80f);            if(explosiontimer > 3)                gamestate = 3;        }    }    private void drawPausedUI()    {        // Darken the entire screen to display the Paused screen.        //g.drawARGB(200, 0, 0, 0);        g.drawRect(0, 0, 801, 1281, Color.BLACK);        g.drawString("Paused", 400, 640, paint);    }    private void drawGameOverUI()    {        g.drawImage(Assets.skybackground, 0, 0);        g.drawImage(Assets.trophy, 270, 680);        g.drawString("Game Over", 350, 270, paint2);        // TODO IF > 5 DIGITS, X++        g.drawString(Integer.toString(game.getHighScore()), 455, 749, paint2);        g.drawString(Integer.toString(score), 420, 630, paintBig);        g.drawImage(Assets.playerGameOver, 635, 165);    }    /*********************  Game States Update *********************/    private void updateMenu(List<TouchEvent> touchEvents, float deltaTime)    {        updatePlayer(touchEvents);        updateBackground();        updateOptions(touchEvents);    }    private void updateRunning(List<TouchEvent> touchEvents, float deltaTime)    {        // Call update() methods and check events        updatePlayer(touchEvents);        updateBackground();        updateEnemy();        updateScore();    }    private void updatePaused(List<TouchEvent> touchEvents)    {        if(touchEvents.size() >= 1)        {            for (int i = 0; i < touchEvents.size(); i++)            {                TouchEvent event = touchEvents.get(i);                if (event.type == TouchEvent.TOUCH_DOWN)                    resume();            }        }    }    private void updateGameOver(List<TouchEvent> touchEvents)    {        if(touchEvents.size() >= 1)        {            for (int i = 0; i < touchEvents.size(); i++)            {                TouchEvent event = touchEvents.get(i);                if(gameoverFlag)                {                    if (event.type == TouchEvent.TOUCH_DOWN)                        ResetVariables();                }                else                {                    if (event.type == TouchEvent.TOUCH_UP)                        gameoverFlag = true;                }            }        }    }    /*********************  Game Sprites Update *********************/    private void updateOptions(List<TouchEvent> touchEvents)    {        if(touchEvents.size() >= 1)        {            for (int i = 0; i < touchEvents.size(); i++)            {                TouchEvent event = touchEvents.get(i);                if (event.type == TouchEvent.TOUCH_DOWN)                {                    if(inBounds(event, player.getX(), player.getY(), player.playerXRadius, player.playerYRadius))                    {                        optionFlag = false;                        gamestate = 1;                    }                    if(inBounds(event, xButtons, ySettings, buttonRadius, buttonRadius))                    {                        if(optionFlag)                            optionFlag = false;                        else                            optionFlag = true;                    }                    if(optionFlag)                    {                        if (inBounds(event, xButtons, ySound, buttonRadius, buttonRadius))                        {                            if (soundFlag)                                soundFlag = false;                            else                                soundFlag = true;                        }                        if (inBounds(event, xButtons, yMusic, buttonRadius, buttonRadius))                        {                            if (musicFlag)                            {                                Assets.theme.play();                                musicFlag = false;                            }                            else                            {                                Assets.theme.pause();                                musicFlag = true;                            }                        }                    }                }            }        }    }    private void updatePlayer(List<TouchEvent> touchEvents)    {        if(gamestate == 1)        {            if (!touchFlag)            {                if (touchEvents.size() >= 1)                {                    for (int i = 0; i < touchEvents.size(); i++)                    {                        TouchEvent event = touchEvents.get(i);                        if (event.type == TouchEvent.TOUCH_DOWN)                        {                            player.setMoving(true);                            touchFlag = true;                        }                    }                }            }            else            {                if (touchEvents.size() >= 1)                {                    for (int i = 0; i < touchEvents.size(); i++)                    {                        TouchEvent event = touchEvents.get(i);                        if (event.type == TouchEvent.TOUCH_UP)                        {                            touchFlag = false;                            player.setMoving(false);                            player.setAcceleration(5);                        }                    }                }            }            if(player.getY() < 0)                player.setMoving(false);            if(player.getY() > 1320)                bExplosionTouchFlag = true;            player.update();        }        animPlayer.update(20);    }    private void updateBackground()    {        if(bglist.get(bglist.size() - 1).getX() < - 800)            bgSpawn = true;        if(bgSpawn)        {            int bgcoords = 900;            for(int i = 0; i < bglist.size(); i++)            {                bglist.get(i).setX(bgcoords);                bglist.get(i).setY(bgRand.nextInt(1000));                BackgroundImageGenerator(bglist.get(i));                bgcoords += 500;            }            bgSpawn = false;        }        for(int i = 0; i < bglist.size(); i++)            bglist.get(i).update();    }    private void updateEnemy()    {        updateActiveEnemy();        updateStaticEnemy();        if(bExplosionTouchFlag)            explosiontimer++;    }    private void updateActiveEnemy()    {        // Active Enemy Update        if(activeEnemylist.get(activeEnemylist.size() - 1).getX() < -100)            bActiveEnemySpawn = true;        if(score > 15)            bIncreaseActiveEnemySpawn = true;        if(bActiveEnemySpawn)        {            if(bIncreaseActiveEnemySpawn && !bActiveEnemySpawnFlag)                IncreaseActiveEnemySpawn();            bActiveEnemySpawn = ActiveEnemyGenerator(false);        }        for(int i = 0; i < activeEnemylist.size(); i++)        {            activeEnemylist.get(i).update(activeEnemySpeed);            if(activeEnemylist.get(i).rEnemy.intersect(player.rPlayer))                bExplosionTouchFlag = true;        }        animEnemy.update(20);    }    private void updateStaticEnemy()    {        // Static Enemy Update        if(staticEnemylist.get(staticEnemylist.size() - 1).getX() < -200)            bStaticEnemySpawn = true;        if(bStaticEnemySpawn)            bStaticEnemySpawn = StaticEnemyGenerator(false);        for(int i = 0; i < staticEnemylist.size(); i++)        {            staticEnemylist.get(i).update(staticEnemySpeed);            if(staticEnemylist.get(i).rEnemy.intersect(player.rPlayer))                bExplosionTouchFlag = true;        }    }    private void updateScore()    {        scoretimer++;        if(scoretimer == 50)        {            score++;            scoretimer = 0;        }    }    private void updateHighScore()    {        if(score > game.getHighScore())            game.updateHighScore(score);    }    private void ResetVariables()    {        updateHighScore();        player.setX(Assets.xPlayer);        player.setY(Assets.yPlayer);        ActiveEnemyGenerator(false);        StaticEnemyGenerator(false);        score               = 0;        gamestate           = 0;        explosiontimer      = 0;        bExplosionTouchFlag = false;        gameoverFlag        = false;        game.showInterstitial();    }    private void MusicController(boolean paused)    {        if(!musicFlag)        {            if (paused)                Assets.theme.pause();            else                Assets.theme.play();        }    }    /*********************  Game Constructors *********************/    private void ConstructPlayer()    {        // Set Animation and Pictures        animPlayer = new Animation();        animPlayer.addFrame(Assets.playerballoon0, 100);        // Create Player Class        player = new Player(Assets.xPlayer, Assets.yPlayer);        // TouchFlag for Touch Events        touchFlag = false;    }    private void ConstructBackground()    {        bgSpawn = false;        bgRand  = new Random();        bglist  = new ArrayList<>();        int bgcoords = 800;        for(int i = 0; i < 10; i++)        {            bglist.add(new Background(bgcoords, bgRand.nextInt(1000), 3));            BackgroundImageGenerator(bglist.get(i));            bgcoords += 500;        }    }    private void ConstructEnemy()    {        ConstructActiveEnemy();        ConstructStaticEnemy();    }    private void ConstructActiveEnemy()    {        animEnemy = new Animation();        animEnemy.addFrame(Assets.enemybird0, 100);        animEnemy.addFrame(Assets.enemybird1, 100);        animEnemy.addFrame(Assets.enemybird2, 100);        animEnemy.addFrame(Assets.enemybird3, 100);        enemyRand                   = new Random();        activeEnemylist             = new ArrayList<>();        activeEnemySpawn            = new int[3];        activeEnemySpawn[0]         = 140;        activeEnemySpawn[1]         = 400;        activeEnemySpawn[2]         = 660;        bActiveEnemySpawn           = false;        bActiveEnemySpawnFlag       = false;        bIncreaseActiveEnemySpawn   = false;        activeEnemySize             = 10;        activeEnemySpeed            = 8;        // Actual Dimensions 95x70        activeEnemyXRadius          = 85;        activeEnemyYRadius          = 60;        bExplosionTouchFlag         = false;        explosiontimer              = 0;        ActiveEnemyGenerator(true);    }    private void ConstructStaticEnemy()    {        staticEnemylist         = new ArrayList<>();        staticEnemySpawn        = new int[3];        staticEnemySpawn[0]     = 880;        staticEnemySpawn[1]     = 980;        staticEnemySpawn[2]     = 1080;        bStaticEnemySpawn       = false;        staticEnemySize         = 10;        staticEnemySpeed        = 5;        StaticEnemyGenerator(true);    }    private void ConstructOptions()    {        optionFlag      = false;        soundFlag       = false;        musicFlag       = false;        xButtons        = 60;        ySettings       = 90;        ySound          = 240;        yMusic          = 350;        buttonRadius    = 100;    }    private void ConstructScore()    {        score = 0;        scoretimer = 0;        /**  Define a paint object ( To Write On Screen )   **/        paint = new Paint();        paint.setTextSize(125);        paint.setStrokeWidth(5);        paint.setTextAlign(Paint.Align.CENTER);        paint.setAntiAlias(true);        paint.setColor(Color.WHITE);        paint2 = new Paint();        paint2.setTextSize(93);        paint2.setStrokeWidth(5);        paint2.setTextAlign(Paint.Align.CENTER);        paint2.setAntiAlias(true);        paint2.setColor(Color.YELLOW);        paint2.setStyle(Paint.Style.FILL);        paintBig = new Paint();        paintBig.setTextSize(160);        paintBig.setStrokeWidth(5);        paintBig.setTextAlign(Paint.Align.CENTER);        paintBig.setAntiAlias(true);        paintBig.setColor(Color.YELLOW);        paintBig.setStyle(Paint.Style.FILL);    }    private void BackgroundImageGenerator(Background bgImage)    {        switch(bgRand.nextInt(5))        {            case 0:                bgImage.setBgImage(Assets.bgcloud1);                break;            case 1:                bgImage.setBgImage(Assets.bgcloud2);                break;            case 2:                bgImage.setBgImage(Assets.bgcloud3);                break;            case 3:                bgImage.setBgImage(Assets.bgcloud4);                break;            case 4:                bgImage.setBgImage(Assets.bgcloud5);                break;            default:                break;        }    }    private boolean ActiveEnemyGenerator(boolean onCreate)    {        int activeEnemeySpawnRand;        int enemyCounter0           = 0;        int enemyCounter1           = 0;        int enemyCounter2           = 0;        int xEnemyCoords            = 1000;        if(onCreate)        {            for(int i = 0; i < activeEnemySize; i++)            {                activeEnemeySpawnRand = enemyRand.nextInt(3);                if(activeEnemeySpawnRand == 0)                    enemyCounter0++;                else if(activeEnemeySpawnRand == 1)                    enemyCounter1++;                else                    enemyCounter2++;                if(enemyCounter0 >= 2)                {                    activeEnemylist.add(new Enemy(xEnemyCoords, activeEnemySpawn[1], activeEnemyXRadius, activeEnemyYRadius));                    enemyCounter0 = 0;                }                else if(enemyCounter1 >= 2)                {                    activeEnemylist.add(new Enemy(xEnemyCoords, activeEnemySpawn[2], activeEnemyXRadius, activeEnemyYRadius));                    enemyCounter1 = 0;                }                else if(enemyCounter2 >= 2)                {                    activeEnemylist.add(new Enemy(xEnemyCoords, activeEnemySpawn[0], activeEnemyXRadius, activeEnemyYRadius));                    enemyCounter2 = 0;                }                else                {                    activeEnemylist.add(new Enemy(xEnemyCoords, activeEnemySpawn[activeEnemeySpawnRand], activeEnemyXRadius, activeEnemyYRadius));                }                xEnemyCoords += enemyRand.nextInt(150) + 200;            }            return true;        }        else        {            for (int i = 0; i < activeEnemylist.size(); i++)            {                activeEnemeySpawnRand = enemyRand.nextInt(3);                if (activeEnemeySpawnRand == 0)                    enemyCounter0++;                else if (activeEnemeySpawnRand == 1)                    enemyCounter1++;                else                    enemyCounter2++;                if (enemyCounter0 >= 2)                {                    activeEnemylist.get(i).setX(xEnemyCoords);                    activeEnemylist.get(i).setY(activeEnemySpawn[1]);                    enemyCounter0 = 0;                }                else if (enemyCounter1 >= 2)                {                    activeEnemylist.get(i).setX(xEnemyCoords);                    activeEnemylist.get(i).setY(activeEnemySpawn[2]);                    enemyCounter1 = 0;                }                else if (enemyCounter2 >= 2)                {                    activeEnemylist.get(i).setX(xEnemyCoords);                    activeEnemylist.get(i).setY(activeEnemySpawn[0]);                    enemyCounter2 = 0;                }                else                {                    activeEnemylist.get(i).setX(xEnemyCoords);                    activeEnemylist.get(i).setY(activeEnemySpawn[activeEnemeySpawnRand]);                }                xEnemyCoords += enemyRand.nextInt(150) + 200;            }            return false;        }    }    private boolean StaticEnemyGenerator(boolean onCreate)    {        int xEnemyCoords        = 1500;        int staticEnemey0XRad   = 180;        int staticEnemey1XRad   = 150;        int staticEnemey2XRad   = 130;        int staticEnemeyYRad    = 380;        if(onCreate)        {            for(int i = 0; i < staticEnemySize; i++)            {                switch (enemyRand.nextInt(3))                {                    case 0:                        staticEnemylist.add(new Enemy(xEnemyCoords, staticEnemySpawn[enemyRand.nextInt(3)], staticEnemey0XRad, staticEnemeyYRad));                        staticEnemylist.get(i).setEnemyImage(Assets.enemybuilding0);                        break;                    case 1:                        staticEnemylist.add(new Enemy(xEnemyCoords, staticEnemySpawn[enemyRand.nextInt(3)], staticEnemey1XRad, staticEnemeyYRad));                        staticEnemylist.get(i).setEnemyImage(Assets.enemybuilding1);                        break;                    case 2:                        staticEnemylist.add(new Enemy(xEnemyCoords, staticEnemySpawn[enemyRand.nextInt(3)], staticEnemey2XRad, staticEnemeyYRad));                        staticEnemylist.get(i).setEnemyImage(Assets.enemybuilding2);                        break;                    default:                        break;                }                xEnemyCoords += enemyRand.nextInt(150) + 200;            }            return true;        }        else        {            for(int i = 0; i < staticEnemylist.size(); i++)            {                staticEnemylist.get(i).setX(xEnemyCoords);                staticEnemylist.get(i).setY(staticEnemySpawn[enemyRand.nextInt(3)]);                switch (enemyRand.nextInt(3))                {                    case 0:                        staticEnemylist.get(i).setRect(staticEnemey0XRad, staticEnemeyYRad);                        staticEnemylist.get(i).setEnemyImage(Assets.enemybuilding0);                        break;                    case 1:                        staticEnemylist.get(i).setRect(staticEnemey1XRad, staticEnemeyYRad);                        staticEnemylist.get(i).setEnemyImage(Assets.enemybuilding1);                        break;                    case 2:                        staticEnemylist.get(i).setRect(staticEnemey2XRad, staticEnemeyYRad);                        staticEnemylist.get(i).setEnemyImage(Assets.enemybuilding2);                        break;                    default:                        break;                }                xEnemyCoords += enemyRand.nextInt(150) + 200;            }            return false;        }    }    private void IncreaseActiveEnemySpawn()    {        int activeEnemeySpawnRand;        int enemyCounter0           = 0;        int enemyCounter1           = 0;        int enemyCounter2           = 0;        int xEnemyCoords            = 1000;        int additionalSpawn         = 5;        for(int i = 0; i < additionalSpawn; i++)        {            activeEnemeySpawnRand = enemyRand.nextInt(3);            if(activeEnemeySpawnRand == 0)                enemyCounter0++;            else if(activeEnemeySpawnRand == 1)                enemyCounter1++;            else                enemyCounter2++;            if(enemyCounter0 >= 2)            {                activeEnemylist.add(new Enemy(xEnemyCoords, activeEnemySpawn[1], activeEnemyXRadius, activeEnemyYRadius));                enemyCounter0 = 0;            }            else if(enemyCounter1 >= 2)            {                activeEnemylist.add(new Enemy(xEnemyCoords, activeEnemySpawn[2], activeEnemyXRadius, activeEnemyYRadius));                enemyCounter1 = 0;            }            else if(enemyCounter2 >= 2)            {                activeEnemylist.add(new Enemy(xEnemyCoords, activeEnemySpawn[0], activeEnemyXRadius, activeEnemyYRadius));                enemyCounter2 = 0;            }            else            {                activeEnemylist.add(new Enemy(xEnemyCoords, activeEnemySpawn[activeEnemeySpawnRand], activeEnemyXRadius, activeEnemyYRadius));            }            xEnemyCoords += enemyRand.nextInt(150) + 200;        }        bIncreaseActiveEnemySpawn   = false;        bActiveEnemySpawnFlag       = true;        activeEnemySpeed            = 10;    }    /** Don't need Game Destructors anymore as everything is in a Single Screen **/    private void nullify()    {        // Set all variables to null; Variables will be recreated in the Constructor        // Call Garbage Collector to clean up memory        System.gc();    }}    /*    // Token Sprites    private int xToken, yToken;    private int nTokens, nTokensRemoved;    private int tokenGap;    private boolean bTokenRespawn;    private ArrayList<Token> tokenList;    private Image tokenImage;    private void ConstructTokens()    {        tokenImage      = Assets.token0;        nTokens         = 10;        nTokensRemoved  = 0;        bTokenRespawn   = false;        tokenGap        = 128;        xToken          = 900;        yToken          = 600;        tokenList       = new ArrayList<>();        for(int i = 0; i < nTokens; i++)        {            tokenList.add(new Token(xToken, yToken));            xToken += tokenGap;        }        xToken = 900;    }    private void updateTokens()    {        for(int i = 0; i < tokenList.size(); i++)        {            tokenList.get(i).update();            if(Rect.intersects(tokenList.get(i).rStar, player.rPlayer))            {                tokenList.get(i).setX(5000);                Assets.coinSound.play(0.35f);            }        }    }    ////////////////////////////////////////////////////////////////////////////////////////////////    // Assets can only be read; you can't write to files in assets folder    private void updateHighScoreWrong()    {        BufferedWriter writer;        if(score > Integer.parseInt(Assets.score))        {            try            {                writer = new BufferedWriter(new OutputStreamWriter(game.getFileIO().writeFile("score.txt")));                writer.write(Integer.toString(score));                Assets.score = Integer.toString(score);                writer.flush();                writer.close();            }            catch (IOException e)            {                e.printStackTrace();            }        }    }     */